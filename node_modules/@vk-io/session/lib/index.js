'use strict';

class MemoryStorage {
    constructor({ store = new Map() } = {}) {
        this.store = store;
    }
    async get(key) {
        return this.store.get(key);
    }
    async set(key, value) {
        this.store.set(key, value);
        return true;
    }
    async delete(key) {
        return this.store.delete(key);
    }
    // eslint-disable-next-line class-methods-use-this
    async touch() {
        // ...
    }
}

class SessionManager {
    constructor(options = {}) {
        this.storage = options.storage || (new MemoryStorage());
        this.contextKey = options.contextKey || 'session';
        this.getStorageKey = options.getStorageKey || ((context) => (String(context.senderId || context.userId)));
    }
    /**
     * Returns the middleware for embedding
     */
    get middleware() {
        const { storage, contextKey, getStorageKey } = this;
        return async (context, next) => {
            const storageKey = getStorageKey(context);
            let changed = false;
            const wrapSession = (targetRaw) => (
            // eslint-disable-next-line no-use-before-define
            new Proxy({ ...targetRaw, $forceUpdate }, {
                set: (target, prop, value) => {
                    changed = true;
                    target[prop] = value;
                    return true;
                },
                deleteProperty: (target, prop) => {
                    changed = true;
                    delete target[prop];
                    return true;
                }
            }));
            const $forceUpdate = () => {
                // eslint-disable-next-line no-use-before-define
                if (Object.keys(session).length > 1) {
                    changed = false;
                    // eslint-disable-next-line no-use-before-define
                    return storage.set(storageKey, session);
                }
                return storage.delete(storageKey);
            };
            const initialSession = await storage.get(storageKey) || {};
            let session = wrapSession(initialSession);
            Object.defineProperty(context, contextKey, {
                get: () => session,
                set: (newSession) => {
                    session = wrapSession(newSession);
                    changed = true;
                }
            });
            await next();
            if (changed) {
                await $forceUpdate();
            }
            else {
                await storage.touch(storageKey);
            }
        };
    }
}

exports.MemoryStorage = MemoryStorage;
exports.SessionManager = SessionManager;
